#### Java内存模型（Java Memory Model）
简称JMM,定义了java虚拟机jvm在计算机内存ram中的工作方式。  
详细：程序中的变量存储在主内存中，每个线程拥有自己的工作内存，并存放主内存变量的拷贝，线程读写自己的工作内存，通过主内存进行变量交互。  
JMM就是规定了工作内存和主内存之间变量访问的细节，通过保障原子性，有序性，可见性来实现线程的有效协同和数据安全。  
#### JVM内存
JVM内存分为5个区，堆，JVM栈（又称栈），方法区，本地方法栈，程序计数器。
- 栈。每启动一个新线程JVM就会为这个线程分配一个栈，以栈帧为单位保存线程的运行状态。jvm对栈只有两种操作：以栈帧为单位的入栈和出栈。栈中只保存基本数据类型和对象的引用。栈中的数据都是私有的，其他栈不能访问
- 堆。重点关注
- 方法区。又称为非堆区，静态区，永久代。存储的是每个类的信息（包括类的名称，方法，字段，接口等），静态变量，常量等。在Full GC的时候也会回收。
- 本地方法栈。和jvm栈差不多，只不过是为jvm使用到的native方法服务的。又称C栈，使用C或者C++代码实现的。
- 程序计数器。用来保存当前线程执行的内存地址。因为jvm是支持多线程轮流切换的，为了保证切换回来还能恢复到原先的状态，用这个独立的计数器来记录。这个区域是唯一不会栈溢出的。
堆。被划分为两个不同的区域：新生代和老年代，比例为1：2。新生代又被分为三个区域，Eden区，From Survivor区，To Survivor区，比例为8：1：1，所以新生代可用内存为90%  
数据先被存到到新生代的eden区，当eden区满了后，会进行一次Minor GC，把需要保留的数据存到到From区，并将这些对象的年龄设为1，eden区清空；直到From区满了后，对From区也进行Minor GC，需要保留的数据年龄加1，用复制算法移动到To区，From区和To区的数据每被复制到对方一次，其数据年龄都加1，直到阈值15后，会被移动老年代。  
老年代的垃圾回收没有新生代频繁，毕竟熬过了From To区15次垃圾回收都没回收掉，如果老年代内存满的时候，会触发一次Full gc，Full GC会中断所有的线程，等GC执行完毕再恢复，执行时间要更长，因为涉及到更多的对象扫描。  
老年代采用的是标记清除和标记整理算法。新生代采用的是分代复制算法。老年代触发内存溢出是因为老年代Full Gc后还是无法存放从survivor区复制过来的对象。  
可能两种情况:采用标记清除后因为有不连续的内存，而需要存放的对象需要较大的连续的内存空间。或者采用标记整理后可用的内存空间不足以存放需要的大小。
#### 垃圾回收算法
- 标记清除。分标记和清除两个阶段，先标记可回收的对象，再回收。缺点是会产生不连续的内存，碎片化过多会使以后需要分配较大对象时找不到足够大的连续内存，触发oom。
- 标记整理。标记清除算法的优化版，标记可回收的对象，然后将存活的对象移到一端，清理掉边界以外的内存。避免了标记清除算法的碎片化问题。
- 复制算法。将内存分为两块，每次只使用其中一块，当这块内存满了时，就把存活的对象复制到另一块，并清空这一块内存。缺点是需要两倍的内存空间。
- 分代算法。根据垃圾回收对象的特性，不同阶段使用不同的GC算法。比如内存分为老年代和新生代，使用不同的GC算法