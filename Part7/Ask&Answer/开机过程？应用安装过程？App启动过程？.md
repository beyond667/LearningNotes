## 开机过程
我们知道，Android是基于Linux系统的，按下电源键后，会启动Bootload引导程序，开始加载linux内核，然后会启动0号init进程，这个进程会加载init.rc配置文件，配置文件里有个命令会启动zygote进程，前面的进程都属于Linux层的，zygote进程启动后Android层的第一个进程就启动好了。  
zygote会fork出一个很重要的进程SystemServer，因为AMS,PMS,WMS都是在这里初始化的，zygote进程会启动一个socket服务端，SystemServer进程会启动一个socket客户端，后续AMS会通过systemserver的socket客户端跟zygote通信  
SystemServer里面要初始化的服务启动完成后会调用systemReady，这里会启动SystemUI和启动Launcher，systemUi启动完代表系统导航栏和状态栏已经初始化完，然后会启动Launcher，通过startHomeActivityLocked把luancher的activity置于栈顶，通过resumeFocusedStackTopActivityLocked将栈顶的Activity显示到界面上，launcher的启动就已经完成了（这里面牵涉到app的启动流程）  
## 应用安装过程
应用安装有4种方式，系统应用，应用商城，adb安装，第三方应用安装，前三种都没有安装界面，最后有安装界面，由packageinstaller.apk应用处理安装及卸载过程的界面。
PackageInstallActivity负责解析包，判断apk是否可用，检验签名等，然后向PMS的handler发送一条消息，PMS主要做了以下几件事:  
把apk文件copy到data/app下面，通过dexopt操作，优化dex文件到data/dalvik-cache文件夹下，在data/data目录下创建当前应用的数据目录，并解析apk信息，更新该应用的权限信息，最终完成安装或者更新后，会发送一条广播Intent.ACTION_PACKAGE_ADDED这样应用就安装完成了
## App启动流程
我们知道，桌面Launcher实际上也是个app，点击某个icon相当于执行了activity.startActivity方法，一直执行到Instrumentation.execStartActivity方法，通过Binder IPC的方式拿到ActivityManagerNative，这个是ActivityManagerService的代理方法，  
接着执行ActivityManagerService.startActivity,startActivityAsUser,startActivityMayWait,一直到ActivityStarter.startActivityLocked,startActivityUnchecked,  
ActivityStack.startActivityLocked,ensureActivitiesVisibleLocked,makeVisibleAndRestartIfNeeded,makeVisibleAndRestartIfNeeded,然后到ActivityStackSupervisor.startSpecificActivityLocked  
然后到ams.startProcessLocked,最终通过Process.start通过zogate进程fork出来新的进程，并指定回调的类是ActivityThread，新的进程初始化完后会调用activityThread的main方法，这里会在当前线程初始化一个Looper，也就是我们说的主线程，  
初始化ActivityThread并调用attach方法，通过Binder机制，调用ams.attachApplication,attachApplicationLocked,最终到ApplicationThreadNative.bindApplication,绑定完信息后，  
然后Binder调用到ActivityThread.bindApplication,通过handler机制，发送BIND_APPLICATION,最终执行handleBindApplication，绑定完之后会new Instrumentation,然后执行Instrumentation.callApplicationOnCreate,这个会执行我们application的oncreate方法  
ams绑定完application后，在attachApplicationLocked方法后面ActivityStackSupervisor.attachApplicationLocked，realStartActivityLocked来调用AplicationThread.scheduleLaunchActivity,通过binder调用ActivityThread的scheduleLaunchActivity  
这里通过handler发送LAUNCH_ACTIVITY的message，然后执行handleLaunchActivity，这里会执行Instrumentation.callActivityOnCreate，来调用activity的oncreate方法，继续ActivityThread.performResumeActivity会执行anctivity.performStart方法，anctivity.performResume，里面会执行Instrumentation.callActivityOnStart callActivityOnResume 
通过Instrumentation来管理activity的生命周期
  





