代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。属于结构型模式，从代码角度来说分为静态代理和动态代理  
静态代理就是在运行前就已经存在代理类的字节码文件，代理类和委托类就已经确定了。动态代理是在程序运行期间由反射机制动态生成，所以不存在代理类的字节码文件，代理类和委托类是在运行时确定  
静态代理原理:代理类和真实类都实现同一个接口，在代理类的构造方法里传入真实类的实例，在代理类的实现方法里调用真实类的实现方法。  
动态代理原理:是根据java提供的代理接口InvocationHandler，并重写其invoke方法，然后通过Proxy.newProxyInstance，传入类加载器，代理接口，和invocationHandler，返回该对象的代理对象。  
#### 代理模式优点缺点 
代理作为调用者和真实对象的中间层，降低了模块和系统的耦合性。代理对象能够控制调用者的访问权限，起到了保护真实对象的作用  
缺点：由于在调用者和真实对象之间增加了代理对象，因此处理可能会变慢，还可能增加系统的复杂度  
静态代理的缺点：如果接口新增加一个方法，代理类和实现类都要实现这个方法，违背开闭原则。代理对象只能代理这一种类型的对象，如果要代理多个类型的对象，必须要为每一种对象都进行代理，规模稍大就不适合用静态代理了。  
动态代理的优点：通过一个代理类就可以完成全部的代理功能，新增加方法时，不需要像静态代理一样每个方法都再实现一次，因为其接口中声明的所有方法都会被转移到InvocationHandler.invoke方法中处理，动态代理使类的职责更单一，复用性更强  
动态代理缺点：不能对类进行代理，只能对接口代理。因为java不允许多继承，而动态代理生成的$Proxy代理类已经继承了Proxy对象，如果可以对类进行代理，就有可能多继承  
#### 应用场景 
一个对象不能或者不想直接访问另一个对象，可以通过代理对象间接访问。或者被访问的对象不想暴露全部的内容，可以使用代理去掉不想被访问的内存。  
android中进程间通信Bindler机制就大量运用了代理模式，比如AMP是AMS的代理，AMS也持有所有应用的IApplicationThread代理对象




